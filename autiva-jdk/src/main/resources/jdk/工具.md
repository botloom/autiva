# 第一部分：JDK自带工具

### 1. `javac` - Java 编译器
**语法**
```bash
javac [options] [sourcefiles] [@files]
```
**描述**

读取 Java 类和接口定义，并将它们编译成字节码和 `.class` 文件。

**重要参数详解**

| 参数 | 描述 |
| :--- | :--- |
| **`-d <directory>`** | 指定存放生成的类文件的根目录。例如 `javac -d build src/MyClass.java`。 |
| **`-cp <path>`** <br> **`-classpath <path>`** | 指定查找用户类文件和 JAR 包的位置。用于编译时的依赖解析。 |
| **`--module-path <path>`** <br> **`-p <path>`** | 指定查找应用模块的路径。用于模块化编译。 |
| **`--add-modules <mod>[,<mod>...]`** | 除了根模块之外，还要解析的模块。`ALL-MODULE-PATH` 表示解析所有可用模块。 |
| **`--release <release>`** | **（推荐）** 指定目标 Java 版本。它同时设置 `-source` 和 `-target`，并确保不使用比指定版本更新的 API。 |
| **`-source <release>`** | 指定源代码兼容的 Java 版本。 |
| **`-target <release>`** | 指定生成的 `.class` 文件兼容的 JVM 版本。 |
| **`-g`** | 生成所有调试信息，包括局部变量。默认只生成行号和源文件信息。 |
| **`-nowarn`** | 禁用所有警告信息。 |
| **`-Xlint:all`** | 启用所有推荐的警告信息，有助于代码规范。 |
| **`-proc:none`** | 禁用注解处理，可以加快编译速度。 |
| **`-encoding <encoding>`** | 指定源文件使用的字符编码，如 `UTF-8`。 |
| **`@<files>`** | 从文件中读取源文件和选项。一个文件名一行。 |
---

### 2. `java` - Java 应用启动器

**语法**

```bash
java [options] <mainclass> [args...]
java [options] -jar <jarfile> [args...]
```

**描述**

启动一个 Java 应用程序。

**重要参数详解**

| 参数 | 描述 |
| :--- | :--- |
| **`-cp <path>`** <br> **`-classpath <path>`** | 指定查找用户类文件和 JAR 包的路径。 |
| **`--module-path <path>`** <br> **`-p <path>`** | 指定查找应用模块的路径。 |
| **`--add-modules <mod>[,<mod>...]`** | 除了根模块之外，还要解析的模块。 |
| **`--add-opens <module>/<package>=<other-module>[,<other-module>...]`** | 在运行时深度反射打开指定模块的包，以解决某些框架（如 Spring, Mockito）的反射访问问题。 |
| **`-jar <jarfile>`** | 执行一个封装在 JAR 文件中的应用程序。 |
| **`-Xms<size>`** | 设置 JVM 初始堆大小。例如 `-Xms512m`。 |
| **`-Xmx<size>`** | 设置 JVM 最大堆大小。例如 `-Xmx4g`。 |
| **`-Xmn<size>`** | 设置堆的年轻代大小。 |
| **`-XX:MetaspaceSize=<size>`** <br> **`-XX:MaxMetaspaceSize=<size>`** | 设置元空间的初始和最大大小。 |
| **`-XX:+UseG1GC`** | 使用 G1 垃圾回收器（JDK 9+ 默认）。 |
| **`-XX:+UseZGC`** | 使用 ZGC，一个超低延迟的回收器。 |
| **`-XX:+UseShenandoahGC`** | 使用 Shenandoah GC，另一个低延迟回收器。 |
| **`-D<property>=<value>`** | 设置系统属性。例如 `-Dfile.encoding=UTF-8`。 |
| **`-agentlib:jdwp=...`** | 加载 JDWP 调试库，用于远程调试。 |
| **`-verbose:class`** | 在类加载时打印信息。 |
| **`-version`** | 打印产品版本并退出。 |
---

### 3. `jar` - Java 归档工具

**语法**

```bash
jar [ctxui][vfmn0PMe] [jarfile] [manifestfile] [entrypoint] [-C dir] files ...
```

**描述**

创建和管理 JAR (Java Archive) 文件。

**重要参数详解**

| 操作参数 | 描述 |
| :--- | :--- |
| **`c`** | 创建新的归档文件。 |
| **`t`** | 列出归档文件的内容目录。 |
| **`x`** | 从归档文件中提取指定的（或所有）文件。 |
| **`u`** | 更新现有的归档文件。 |
| **`i`** | 为指定的 JAR 文件生成索引信息。 |
| 修饰参数 | 描述 |
| :--- | :--- |
| **`v`** | 在标准输出中生成详细输出。 |
| **`f <file>`** | **（必需）** 指定归档文件名。 |
| **`m <file>`** | 指定 `MANIFEST.MF` 清单文件。 |
| **`e <entrypoint>`** | 指定捆绑到可执行 JAR 文件中的独立应用程序的入口点。 |
| **`0`** | 仅存储，不使用 ZIP 压缩。 |
| **`P`** | 保留文件名中的前导 `/`（绝对路径）和 `..`（父目录）组件。 |
| **`-C <dir>`** | 在处理后续文件时，临时切换到指定目录。 |
---

### 4. `javap` - Java 类文件反汇编器

**语法**

```bash
javap [options] classes...
```

**描述**

反汇编一个或多个类文件，输出其内部结构、字节码等信息。

**重要参数详解**

| 参数 | 描述 |
| :--- | :--- |
| **`-help`** <br> **`--help`** <br> **`-?`** | 输出帮助信息。 |
| **`-version`** | 版本信息。 |
| **`-v`** <br> **`-verbose`** | 输出附加信息（包括行号和本地变量表、常量池等）。 |
| **`-l`** | 输出行号和本地变量表。 |
| **`-public`** | 仅显示 `public` 类和成员。 |
| **`-protected`** | 显示 `public` 和 `protected` 类和成员。 |
| **`-package`** | 显示 `public`, `protected`, 和包私有类和成员。 |
| **`-private`** <br> **`-p`** | 显示所有类和成员（包括 `private`）。 |
| **`-c`** | 对方法进行反汇编，显示 JVM 字节码指令。**（最常用）** |
| **`-s`** | 输出内部类型签名。 |
| **`-sysinfo`** | 显示正在处理的类的系统信息（路径、大小、修改日期、MD5）。 |
| **`-constants`** | 显示最终常量。 |
---

### 5. `jlink` - 自定义运行时镜像创建工具

**语法**

```bash
jlink [options] --module-path <modulepath> --add-modules <modules>[,<modules>...] --output <path>
```

**描述**

根据一组模块及其依赖，组装和优化一个自定义的、精简的 JRE 运行时镜像。

**重要参数详解**

| 参数 | 描述 |
| :--- | :--- |
| **`--module-path <path>`** <br> **`-p <path>`** | **（必需）** 指定查找模块的路径。 |
| **`--add-modules <mod>[,<mod>...]`** | **（必需）** 指定要添加到镜像中的根模块。`ALL-MODULE-PATH` 表示添加路径上所有模块。 |
| **`--output <path>`** | **（必需）** 指定生成的链接镜像的输出目录。 |
| **`--launcher <name>=<module>[/<mainclass>]`** | 在生成的镜像中 `bin/` 目录下创建一个命令行启动器。 |
| **`--compress=<level>`** | 在生成的镜像中压缩资源。`0`=无, `1`=字符串常量池, `2`=所有。 |
| **`--strip-debug`** | 从镜像中剥离调试信息。 |
| **`--strip-native-commands`** | 从镜像中剥离本地命令。 |
| **`--no-header-files`** <br> **`--no-man-pages`** | 从镜像中排除头文件和 man 页。 |
| **`--order-resources=<patternlist>`** | 资源排序模式。 |
| **`--suggest-providers`** | 建议提供者。 |
---

### 6. `jpackage` - 自包含应用打包工具

**语法**

```bash
jpackage [options]
```
**描述**

将 Java 应用打包成平台原生的、可安装的软件包（如 `exe`, `msi`, `dmg`, `deb`, `rpm`）。

**重要参数详解**

| 参数 | 描述 |
| :--- | :--- |
| **`--type <type>`** | 要创建的包类型。例如 `exe`, `msi`, `rpm`, `deb`, `dmg`, `pkg`。 |
| **`--name <name>`** | 应用程序和安装程序的名称。 |
| **`--app-version <version>`** | 应用程序的版本，格式为 `major.minor.micro`。 |
| **`--dest <path>`** | 输出文件的位置。 |
| **`--input <path>`** | 包含要打包的文件（JARs）的目录。 |
| **`--main-jar <path>`** | 应用程序的主 JAR。 |
| **`--main-class <classname>`** | 应用程序的主类（如果主 JAR 的清单中未指定）。 |
| **`--module` / `--module-path` / `--add-modules`** | 用于模块化应用的打包参数。 |
| **`--runtime-image <path>`** | 要打包的自定义运行时镜像的路径（通常由 `jlink` 创建）。 |
| **`--icon <path>`** | 应用程序图标文件的路径。 |
| **`--license-file <path>`** | 许可证文件的路径。 |
| **`--install-dir <path>`** | 绝对路径，用于安装应用程序。 |
| **`--resource-dir <path>` | 覆盖 `jpackage` 资源的目录。 |
| **`--java-options <options>`** | 传递给 Java 运行时的选项。 |
| **`--arguments <arguments>`** | 应用程序的命令行参数。 |
---

### 7. 性能、分析和监控工具

#### `jps` - JVM Process Status Tool

**语法**: `jps [options] [hostid]`

**重要参数**:

| 参数 | 描述 |
| :--- | :--- |
| **`-q`** | 只输出本地虚拟机的 LVMID，不输出类名。 |
| **`-l`** | 输出主类的全名或 JAR 文件的完整路径。 |
| **`-m`** | 输出传递给 `main` 函数的参数。 |
| **`-v`** | 输出传递给 JVM 的参数。 |

#### `jstat` - JVM Statistics Monitoring Tool

**语法**: `jstat -<option> [-t] [-h<lines>] <vmid> [<interval> [<count>]]`

**重要参数**:

| 选项 | 描述 |
| :--- | :--- |
| **`-class`** | 监视类加载、卸载数量及总空间。 |
| **`-compiler`** | 监视 JIT 编译器。 |
| **`-gc`** | 监视堆各区域（Eden, S0, S1, Old, Metaspace）的使用情况、GC 次数和时间。 |
| **`-gccapacity`** | 监视堆各区域的容量及其对应的空间。 |
| **`-gcutil`** | **（常用）** 与 `-gc` 类似，但以百分比形式显示空间使用率。 |
| **`-gcnew`** | 监视新生代 GC 情况。 |
| **`-gcold`** | 监视老年代 GC 情况。 |
| **`-t`** | 在输出第一列显示时间戳。 |
| **`-h<lines>`** | 每隔 `<lines>` 行输出一次表头。 |

#### `jstack` - Java Stack Trace Tool

**语法**: `jstack [-l] <pid>`

**重要参数**:

| 参数 | 描述 |
| :--- | :--- |
| **`-l`** | **（推荐）** 长列表格式。打印关于锁的附加信息。 |
| **`-F`** | 当 `jstack <pid>` 无响应时，强制打印堆栈。 |
| **`-m`** | 打印 Java 和本地 C/C++ 框架的混合堆栈。 |

#### `jmap` - Memory Map for Java

**语法**: `jmap [options] <pid>`

**重要参数**:

| 参数 | 描述 |
| :--- | :--- |
| **`-dump:<options>`** | **（核心）** 生成堆转储。常用格式：`-dump:format=b,file=<filename>`。 |
| **`-heap`** | 打印堆的摘要信息，包括 GC 算法、堆配置和各区域使用情况。 |
| **`-histo[:live]`** | 打印堆中对象的直方图。`live` 选项会先触发一次 Full GC。 |
| **`-clstats`** | 打印类加载器的统计信息。 |
| **`-finalizerinfo`** | 打印等待终结的对象信息。 |

#### `jcmd` - JVM Diagnostic Command Tool

**语法**: `jcmd <pid> <command> [options]`

**重要命令**:

| 命令 | 描述 |
| :--- | :--- |
| **`help`** | 列出所有可用命令。 |
| **`VM.flags`** | 打印 JVM 的 flags。 |
| **`VM.system_properties`** | 打印系统属性。 |
| **`Thread.print`** | **（核心）** 打印所有线程的栈信息（同 `jstack`）。 |
| **`GC.heap_dump <filename>`** | **（核心）** 生成堆转储文件（同 `jmap -dump`）。 |
| **`GC.run`** | 触发一次 GC。 |
| **`GC.run_finalization`** | 触发 `finalization`。 |
| **`VM.native_memory summary`** | 打印本地内存使用情况。 |
| **`JFR.start`** <br> **`JFR.stop`** <br> **`JFR.dump`** <br> **`JFR.check`** | **（核心）** 控制 Java Flight Recorder 的录制。 |

#### `jfr` - Java Flight Recorder

**语法**: `jfr [options] <action> [filename]`

**重要参数**:

| 参数 | 描述 |
| :--- | :--- |
| **`start`** | 开始录制。可设置 `name`, `settings`, `duration`, `filename` 等。 |
| **`stop`** | 停止录制。 |
| **`dump`** | 将录制内容转储到文件。 |
| **`print`** | **（核心）** 解析并打印 `.jfr` 文件的内容。 |
| **`--events <event-names>`** | 在 `print` 时，只打印指定类型的事件。 |
| **`--json`** | 以 JSON 格式输出。 |
| **`--categories <category-names>`** | 在 `print` 时，只打印指定类别的事件。 |

#### `jinfo` - Configuration Info for Java

**语法**: `jinfo [option] <pid>`

**重要参数**:

| 参数 | 描述 |
| :--- | :--- |
| **`-flags`** | 打印 JVM 的 flags。 |
| **`-sysprops`** | 打印系统属性。 |
| **`-flag <name>`** | 打印指定 flag 的值。 |
| **`-flag [+|-]<name>`** | 启用或禁用指定的 flag。 |
| **`-flag <name>=<value>`** | 设置指定 flag 的值。 |


# 第二部分：JDK 自带诊断工具实战（深度解析）

本部分将模拟两个最经典的生产问题场景，带你走完从发现到定位的完整流程。

---

### 场景一：线上应用 CPU 占用率持续 100%

**症状**：应用响应缓慢，甚至无响应，服务器 `top` 命令显示 Java 进程 CPU 占用率接近 100%。
**排查流程与工具链：`jps` -> `jstat` -> `top` -> `jstack`**

#### 步骤 1: 定位问题进程 (`jps`)

```bash
# 找到 CPU 飙高的 Java 进程
jps -l
# 输出：
# 12345 com.example.MyAwesomeApp
# 54321 sun.tools.jps.Jps
```

**结论**：`12345` 是我们的目标 PID。

#### 步骤 2: 初步判断问题类型 (`jstat`)

在深入线程之前，先用 `jstat` 快速排除 GC 问题。

```bash
# 查看该进程的 GC 情况，每秒刷新一次
jstat -gcutil 12345 1s
# 输出（持续观察）：
#  S0     S1     E      O      M     CCS    YGC     YGCT    FGC    FGCT     GCT
#  0.00  50.00  60.00  15.00  95.00  90.00    15    0.120     1    0.050    0.170
```

**分析**：

*   `FGC` (Full GC) 次数很少，`FGCT` (Full GC Time) 几乎不增长。
*   老年代 `O` 使用率稳定。
*   **结论**：问题大概率不是 GC 引起的，而是**业务代码中有死循环或计算密集型任务**。

#### 步骤 3: 定位问题线程与代码 (`top` + `jstack`)

1.  **用 `top` 找到消耗 CPU 最多的线程**：
    ```bash
    top -Hp 12345
    ```
    假设输出显示线程 `12480` 的 CPU 占用率最高。
2.  **将线程 ID 转换为十六进制**：
    ```bash
    printf "%x\n" 12480
    # 输出：30c0
    ```
3.  **用 `jstack` 抓取堆栈并分析**：
    ```bash
    # 抓取堆栈信息并保存到文件
    jstack -l 12345 > thread_dump.txt
    ```
    在 `thread_dump.txt` 中搜索 `nid=0x30c0` (`nid` 就是 Native ID)：
    ```
    "Thread-2" #12 prio=5 os_prio=0 tid=0x00007f8b1c012800 nid=0x30c0 runnable [0x00007f8b050f9000]
       java.lang.Thread.State: RUNNABLE
        at com.example.MyAwesomeApp.runInfiniteLoop(MyAwesomeApp.java:42)
        at com.example.MyAwesomeApp.access$000(MyAwesomeApp.java:10)
        at com.example.MyAwesomeApp$1.run(MyAwesomeApp.java:25)
        - locked <0x00000000d8f8f9d0> (a com.example.MyAwesomeApp)
        ...
    ```

**最终结论**：问题定位成功！是 `MyAwesomeApp.java` 的第 42 行 `runInfiniteLoop` 方法导致了死循环。
---

### 场景二：线上应用频繁发生 `OutOfMemoryError: Java heap space`

**症状**：应用运行一段时间后崩溃，日志中频繁出现 `OutOfMemoryError: Java heap space`。
**排查流程与工具链：`jps` -> `jcmd` -> Eclipse MAT**

#### 步骤 1: 定位问题进程 (`jps`)

同上，找到目标 PID，假设为 `23456`。

#### 步骤 2: 导出堆转储文件 (`jcmd`)

当 OOM 发生时，需要获取 JVM 内存的“快照”进行分析。`jcmd` 是比 `jmap` 更现代、影响更小的选择。

```bash
# 使用 jcmd 导出堆转储文件（会暂停应用一小段时间）
jcmd 23456 GC.heap_dump heap.hprof
# 如果应用已配置 -XX:+HeapDumpOnOutOfMemoryError，JVM 会在 OOM 时自动生成。
```

现在你手上有了一个 `heap.hprof` 文件，它就是 JVM 内存那一刻的完整快照。

#### 步骤 3: 使用 Eclipse MAT 解析堆转储文件

这时，JDK 自带的命令行工具就不够用了，你需要专业的图形化分析工具。

**工具介绍：Eclipse MAT (Memory Analyzer Tool)**
*   **用途**：分析 Java 堆转存文件（`.hprof`）的王者工具。
*   **官网**：`https://www.eclipse.org/mat/`
*   **核心功能**：
    *   **Leak Suspects Report**：自动分析并报告最有可能的内存泄漏嫌疑，是新手和专家的救星。
    *   **Dominator Tree**：显示占用内存最大的对象及其引用链，清晰展示内存的“大头”在哪里。
    *   **Histogram**：列出所有类的实例数量和内存占用，帮你找到哪个类的实例最多、最占空间。
        **MAT 分析 `heap.hprof` 实例：**
1.  打开 MAT，用 `File -> Open Heap Dump` 打开 `heap.hprof`。
2.  选择 **Leak Suspects Report** 并点击 Finish。
3.  MAT 会生成一份报告，其中会包含一个“问题”饼图，并直接指向一个或多个疑似泄漏的对象。
    **报告解读**：
*   **Problem Suspect 1**：MAT 可能会告诉你 `com.example.cache.Manager` 这个类的一个实例占用了 600MB 的堆空间（占总内存的 70%）。
*   **Details**：点击查看详情，MAT 会展示一条从“垃圾回收根”到这个大对象的引用链，例如：
    `com.example.cache.Manager @ 0x12345678`
    `└─ static $statics com.example.cache.Manager.instance`
*   **结论**：`Manager` 类的 `instance` 是一个 `static` 变量，它一直持有一个巨大的 `Map`，这个 `Map` 无法被垃圾回收器回收，导致了内存泄漏。问题瞬间定位！
---

# 第三部分：第三方与辅助工具（提升效率与模拟负载）

除了 JDK 自带的工具，强大的第三方工具和压测工具是现代 Java 开发和运维不可或缺的部分。

---
### 1. VisualVM - “全能型”监控诊断工具

**简介**：VisualVM 是一个集成了多种命令行工具功能的可视化平台，可以看作是 `jstat`, `jstack`, `jmap` 等工具的图形化合集。
**核心功能**：
*   **实时监控**：以图表形式实时展示 CPU、内存、类、线程的运行情况。
*   **线程分析**：实时查看所有线程的状态，可以一键生成 Thread Dump。
*   **堆分析**：一键生成 Heap Dump，并提供简单的分析视图（不如 MAT 深入）。
*   **性能抽样**：对 CPU 或内存进行抽样分析，找出热点方法。
*   **MBean 支持**：可以查看和管理应用的 MBean。
*   **插件生态**：支持插件扩展，如 GC Viewer、Visual GC 等。
    **实战演练：监控本地应用**
1.  **启动**：在命令行直接输入 `jvisualvm`。
2.  **连接应用**：启动你的 Java 应用，它会自动出现在 VisualVM 左侧的“应用程序”列表中。
3.  **分析**：
    *   **监视 Tab**：查看 CPU、堆、PermGen/Metaspace 的实时图表。如果看到堆内存曲线持续上升且不回落，就要警惕内存泄漏。
    *   **线程 Tab**：查看线程数量和状态。如果发现大量线程处于 `BLOCKED` 状态，可能存在锁竞争。
    *   **抽样器 Tab**：点击“CPU”按钮进行一段时间抽样，结束后会显示哪个方法消耗的 CPU 时间最长。
    *   **生成 Heap Dump**：在“监视”Tab 中点击“Heap Dump”按钮，即可生成快照并进行分析。
        **适用场景**：非常适合**本地开发调试**或对**远程应用进行快速、直观的监控**。但对于深度的内存泄漏分析，MAT 仍然是首选。
---

### 2. 压测工具 - 模拟负载，提前发现问题

性能问题不能只在线上解决。压测工具可以模拟大量用户访问，让你在上线前就发现性能瓶颈、GC 问题和稳定性隐患。

#### A. Apache JMeter

**简介**：一个开源的、功能强大的 Java 性能测试工具，主要用于对 Web 应用进行功能和性能测试。

**核心功能**：
*   **多种协议支持**：支持 HTTP, HTTPS, JDBC, JMS, FTP 等多种协议。
*   **图形化界面**：通过拖拽组件的方式设计测试计划，非常直观。
*   **断言与监听器**：可以验证响应结果是否正确，并通过图表和表格查看测试结果。
*   **分布式测试**：可以多台机器协同施压，模拟海量用户。
    **实战演练：对一个 REST API 进行压测**
1.  **创建测试计划**：打开 JMeter，右键 Test Plan -> Add -> Threads (Users) -> Thread Group。
2.  **配置线程数**：设置线程数（用户数）、Ramp-Up Time（多久内启动所有用户）和循环次数。
3.  **添加请求**：右键 Thread Group -> Add -> Sampler -> HTTP Request。填写服务器名、端口、路径等信息。
4.  **添加监听器**：右键 Thread Group -> Add -> Listener -> View Results Tree 或 Summary Report。
5.  **运行测试**：点击工具栏的“启动”按钮。
6.  **分析结果**：在监听器中查看每个请求的响应时间、成功率、吞吐量（TPS）等关键指标。
    **适用场景**：**功能测试、接口性能测试、压力测试**。是测试工程师和后端工程师的必备工具。

---

## 总结与工具选择建议

| 场景 | 推荐工具链 | 说明 |
| :--- | :--- | :--- |
| **CPU 飙高 / 死锁** | `jps` -> `jstat` -> `top` -> `jstack` | 经典的命令行排查流程，快速精准，适用于任何环境。 |
| **内存溢出 (OOM)** | `jcmd` -> **Eclipse MAT** | `jcmd` 导出快照，MAT 进行深度分析，定位泄漏源，是 OOM 问题的标准解法。 |
| **综合性能调优** | `jcmd` (JFR) -> **JDK Mission Control** | 低开销录制，事后全方位分析，是目前最先进的持续性能分析方式。 |
| **实时监控/快速诊断** | **VisualVM** | 图形界面直观，功能全面，适合本地调试和远程快速查看。 |
| **模拟负载/性能测试** | **Apache JMeter** (功能全) / **wrk** (轻量快) | 在上线前主动发现问题，是性能保障的关键环节。 |

