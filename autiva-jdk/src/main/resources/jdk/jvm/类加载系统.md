
## 深入解析 JDK 17 类加载系统：从基础到前沿
### 一、 什么是类加载机制？
类加载机制指的是 Java 虚拟机把描述类的数据从**外部来源**（如本地文件系统、网络等）加载到**内存**，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的 `java.lang.Class` 对象的过程。
这个过程的“生命周期”可以分为七个阶段：
1.  **加载**：通过类的全限定名获取定义此类的二进制字节流，并将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构，最后在内存中生成一个代表这个类的 `java.lang.Class` 对象。
2.  **验证**：确保加载进来的`.class`文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。这是非常重要的一步。
3.  **准备**：为**类变量（即 `static` 修饰的变量）**分配内存并设置其“零值”。这个阶段不分配实例变量，实例变量会随着对象一起分配在 Java 堆中。
4.  **解析**：将常量池内的符号引用（如类名、方法名、字段名）替换为直接引用（内存地址指针或偏移量）的过程。
5.  **初始化**：执行类构造器 `<clinit>()` 方法的过程。该方法由编译器自动收集类中的所有**类变量的赋值动作**和**静态语句块（`static{}`块）**中的语句合并产生。
6.  **使用**：类被应用程序正常使用。
7.  **卸载**：类被垃圾回收器回收，生命周期结束。
    ![类加载生命周期](https://upload-images.jianshu.io/upload_images/2806720-9e8c5e0b1b8f1c8a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
### 二、 类加载器的核心：双亲委派模型
JDK 17 的类加载系统依然遵循着经典的**双亲委派模型**。这个模型是 Java 类加载器之间协作的核心机制，极大地保证了 Java 程序的稳定性和安全性。
#### 1. 三种主要的类加载器
*   **启动类加载器**
    *   最顶层的加载器，由 C++ 实现，是虚拟机自身的一部分。
    *   负责加载 `<JAVA_HOME>/jre/lib` 目录下的核心类库，如 `rt.jar`、`resources.jar` 等，或者被 `-Xbootclasspath` 参数所指定的路径中的类。
    *   它没有父加载器。在 Java 代码中尝试获取它的引用会返回 `null`。
*   **平台类加载器**
    *   从 JDK 9 开始引入，用于取代旧的**扩展类加载器**。
    *   负责加载一些平台相关的模块，如 Java XML 绑定（JAXB）、Java 注解处理（JAVAC）等。它加载的类库通常位于 `<JAVA_HOME>/jre/lib` 目录下，或者由系统属性 `java.ext.dirs` 指定。
    *   它的父加载器是启动类加载器。
*   **应用程序类加载器**
    *   也称为系统类加载器。
    *   负责加载用户类路径上所指定的类库。我们自己编写的 Java 类通常都是由它来加载的。
    *   它的父加载器是平台类加载器。它是 `ClassLoader.getSystemClassLoader()` 方法的返回值。
#### 2. 双亲委派模型的工作流程
双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应有自己的父加载器。这里的“父子关系”通常不是以继承的关系来实现，而是通过**组合**关系来复用父加载器的代码。
其工作过程如下：
> 当一个类加载器收到类加载请求时，它首先不会自己去尝试加载这个类，而是把这个请求**委派**给父类加载器去完成。每一层的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中。只有当**父加载器反馈自己无法完成这个加载请求**（在它的搜索范围内没有找到所需的类）时，子加载器才会尝试自己去加载。
#### 3. 双亲委派模型的好处
*   **避免类的重复加载**：通过委派，可以确保一个类只会被一个加载器加载一次，保证了类在内存中的唯一性。
*   **保证 Java 核心库的安全**：例如，`java.lang.Object` 类存放在 `rt.jar` 中，无论哪个类加载器要加载这个类，最终都会委派给启动类加载器。这样，可以防止恶意代码通过自定义一个 `java.lang.Object` 类来替代系统核心类，从而保证了 Java 程序的稳定和安全。
### 三、 JDK 9+ 的新变革：模块化系统的影响
从 JDK 9 开始，Java 引入了**模块系统**，这对类加载系统产生了深远的影响。JDK 17 作为模块化系统成熟后的版本，其类加载机制与模块化紧密耦合。
#### 1. 从类路径到模块路径
*   **JDK 8 及之前**：类加载器在**类路径**上搜索 `.class` 文件和 JAR 包。这是一个“扁平”的结构，容易出现 JAR 包冲突和“JAR 地狱”问题。
*   **JDK 9 及之后**：引入了**模块路径**。每个 JAR 文件可以声明为一个模块，通过 `module-info.java` 文件明确地定义其**导出的包**和**依赖的模块**。
#### 2. 对类加载器的影响
模块化系统对类加载器进行了增强，使其能够感知模块的存在：
*   **可读性**：一个模块只能“读取”它明确依赖的模块。类加载器在加载一个类时，会检查其所在模块是否对请求加载的模块具有可读性。如果不可读，即使类路径上存在该类，也无法加载。
*   **封装性**：模块可以决定哪些包是公开的（`exports`），哪些是私有的。未导出的包中的类，即使模块是可读的，也无法被外部模块访问和加载。这从根本上解决了反射破坏封装性的问题（除非使用 `--add-opens` 等 JVM 参数）。
*   **类加载器的职责更清晰**：平台类加载器和应用类加载器的职责边界更加明确，它们现在都工作在模块化的框架下，负责加载各自的模块集合。
### 四、 自定义类加载器

#### ClassLoader

#### 1. 如何自定义类加载器？
自定义类加载器只需继承 `java.lang.ClassLoader` 抽象类，并重写其 `findClass(String name)` 方法即可。
```java
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStream;
public class CustomClassLoader extends ClassLoader {
    @Override
    protected Class<?> findClass(String name) throws ClassNotFoundException {
        // 1. 将类的全限定名转换为文件路径
        String path = name.replace('.', '/').concat(".class");
        
        // 2. 读取字节码文件
        try (InputStream inputStream = getResourceAsStream(path)) {
            if (inputStream == null) {
                throw new ClassNotFoundException("Class not found: " + name);
            }
            ByteArrayOutputStream byteStream = new ByteArrayOutputStream();
            int nextValue;
            while ((nextValue = inputStream.read()) != -1) {
                byteStream.write(nextValue);
            }
            byte[] classBytes = byteStream.toByteArray();
            
            // 3. 调用 defineClass 方法将字节数组转换为 Class 对象
            return defineClass(name, classBytes, 0, classBytes.length);
        } catch (IOException e) {
            throw new ClassNotFoundException("Failed to load class " + name, e);
        }
    }
}
```
#### 2. 如何打破双亲委派？
要打破双亲委派模型，需要重写 `loadClass()` 方法，而不是 `findClass()` 方法。因为 `loadClass()` 方法是双亲委派逻辑的核心实现。
```java
@Override
public Class<?> loadClass(String name) throws ClassNotFoundException {
    // 1. 检查类是否已被加载
    Class<?> loadedClass = findLoadedClass(name);
    if (loadedClass != null) {
        return loadedClass;
    }
    // 2. 对于 java. 开头的核心类，仍然委派给父加载器，保证安全
    if (name.startsWith("java.")) {
        try {
            return super.loadClass(name);
        } catch (ClassNotFoundException e) {
            // 忽略，继续尝试自己的加载逻辑
        }
    }
    // 3. 打破委派，直接尝试用自己的 findClass 加载
    try {
        return findClass(name);
    } catch (ClassNotFoundException e) {
        // 4. 如果自己加载失败，再委派给父加载器
        return super.loadClass(name);
    }
}
```
**典型应用场景**：
*   **Tomcat**：每个 Web 应用都有一个独立的 `WebAppClassLoader`，实现了应用间的类隔离。它优先加载自己应用下的类，找不到再委派给父加载器，这是典型的“先子后父”的破坏模型。
*   **JDBC**：使用了**线程上下文类加载器**。核心的 `java.sql.Driver` 接口由启动类加载器加载，但具体的数据库驱动实现（如 MySQL 的驱动）是由第三方厂商提供的，位于应用类路径。JDBC 服务启动时，需要从应用类路径加载驱动实现，此时它通过 `Thread.currentThread().getContextClassLoader()` 获取应用类加载器来完成加载，从而打破了双亲委派。

