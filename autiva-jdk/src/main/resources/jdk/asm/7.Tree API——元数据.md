# 元数据

本章介绍了编译后的 Java 类元数据的树 API，例如注解。它非常简短，因为这些元数据已经在第 4 章中介绍过，而且一旦了解了相应的核心 API，树 API 就很简单了。

## 泛型

树 API 没有提供对泛型类型的支持！实际上，它使用签名来表示泛型类型，就像核心 API 中一样，但没有提供与 `SignatureVisitor` 对应的 `SignatureNode` 类，尽管这是可能的（实际上，至少使用几个 Node 类来区分类型、方法和类签名会方便）。

## 注解

树 API 没有提供对泛型类型的支持！实际上，它使用签名来表示泛型类型，就像核心 API 中一样，但没有提供与 `SignatureVisitor` 对应的 `SignatureNode` 类，尽管这是可能的（实际上，至少使用几个 Node 类来区分类型、方法和类签名会方便）。



```java
public class AnnotationNode extends AnnotationVisitor {
public String desc;
public List<Object> values;
public AnnotationNode(String desc);
public AnnotationNode(int api, String desc);
... // methods of the AnnotationVisitor interface
public void accept(AnnotationVisitor av);
}
```

`desc` 字段包含注解类型，而 `values` 字段包含名称-值对，其中每个名称后面都跟有它的关联值（值的表示方式在 Javadoc 中有描述）。

如您所看到的，`AnnotationNode` 类扩展了 `AnnotationVisitor` 类，并且还提供了一个 `accept` 方法，该方法接受一个对象作为参数，就像 `ClassNode` 和 `MethodNode` 类与类和方法访问者类一起使用一样。因此，我们可以使用用于类和方法的模式来组合核心 API 和树 API 组件。例如，基于继承的模式的“匿名内部类”变体（见 7.2.2 节），适用于注解，给出：

```java
public AnnotationVisitor visitAnnotation(String desc, boolean visible) {
return new AnnotationNode(ASM4, desc) {
@Override public void visitEnd() {
// put your annotation transformation code here
accept(cv.visitAnnotation(desc, visible));
}
};
}
```