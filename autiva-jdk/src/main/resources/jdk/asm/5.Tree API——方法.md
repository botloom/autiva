# 方法

本章解释了如何使用 ASM 树 API 生成和转换方法。它首先单独介绍树 API，并提供了一些示例，然后解释了如何将其与核心 API 结合使用。下一章将介绍泛型和注解的树 API。

## 接口和组件

### 说明

生成和转换方法的 ASM 树 API 基于 `MethodNode` 类。

```java
public class MethodNode ... {
    public int access;
    public String name;
    public String desc;
    public String signature;
    public List<String> exceptions;
    public List<AnnotationNode> visibleAnnotations;
    public List<AnnotationNode> invisibleAnnotations;
    public List<Attribute> attrs;
    public Object annotationDefault;
    public List<AnnotationNode>[] visibleParameterAnnotations;
    public List<AnnotationNode>[] invisibleParameterAnnotations;
    public InsnList instructions;
    public List<TryCatchBlockNode> tryCatchBlocks;
    public List<LocalVariableNode> localVariables;
    public int maxStack;
    public int maxLocals;
}
```

这个类的大多数字段与 `ClassNode` 中相应的字段相似。最重要的字段是最后的几个，从 `instructions` 字段开始。这个字段是一个指令列表，使用 `InsnList` 对象管理，其公共 API 如下：

```java
public class InsnList { // public accessors omitted
    int size();
    AbstractInsnNode getFirst();
    AbstractInsnNode getLast();
    AbstractInsnNode get(int index);
    boolean contains(AbstractInsnNode insn);
    int indexOf(AbstractInsnNode insn);
    void accept(MethodVisitor mv);
    ListIterator iterator();
    ListIterator iterator(int index);
    AbstractInsnNode[] toArray();
    void set(AbstractInsnNode location, AbstractInsnNode insn);
    void add(AbstractInsnNode insn);
    void add(InsnList insns);
    void insert(AbstractInsnNode insn);
    void insert(InsnList insns);
    void insert(AbstractInsnNode location, AbstractInsnNode insn);
    void insert(AbstractInsnNode location, InsnList insns);
    void insertBefore(AbstractInsnNode location, AbstractInsnNode insn);
    void insertBefore(AbstractInsnNode location, InsnList insns);
    void remove(AbstractInsnNode insn);
    void clear();
}
```

`InsnList` 是一个双向链表，其链接存储在 `AbstractInsnNode` 对象本身中。这一点非常重要，因为它对指令对象和指令列表的使用方式有许多影响：
* 一个 `AbstractInsnNode` 对象在指令列表中不能出现多次。
* 一个 `AbstractInsnNode` 对象不能同时属于多个指令列表。
* 因此，将 `AbstractInsnNode` 添加到列表中需要将其从所属的列表中移除（如果有的话）。
* 另一个结果是，将一个列表的所有元素添加到另一个列表中会清空第一个列表。

`AbstractInsnNode` 类是表示字节码指令的类的超类。其公共 API 如下：

```java
public abstract class AbstractInsnNode {
    public int getOpcode();
    public int getType();
    public AbstractInsnNode getPrevious();
    public AbstractInsnNode getNext();
    public void accept(MethodVisitor cv);
    public AbstractInsnNode clone(Map labels);
}
```

它的子类是 `Xxx InsnNode` 类，对应于 `MethodVisitor` 接口的 `visitXxx Insn` 方法，并且都是用相同的方式构建的。例如，`VarInsnNode` 类对应于 `visitVarInsn` 方法，并具有以下结构：

```java
public class VarInsnNode extends AbstractInsnNode {
    public int var;
    public VarInsnNode(int opcode, int var) {
        super(opcode);
        this.var = var;
    }
    ...
}
```

标签和帧，以及行号，尽管它们不是指令，但也由 `AbstractInsnNode` 类的子类表示，即 `LabelNode`、`FrameNode` 和 `LineNumberNode` 类。这使得它们可以被插入到列表中相应的真实指令之前，就像在核心 API 中一样（在核心 API 中，标签和帧是在它们对应的指令之前访问的）。因此，使用 `AbstractInsnNode` 类提供的 `getNext` 方法可以轻松找到跳转指令的目标：这是目标标签后的第一个真实指令。另一个结果是，与核心 API 一样，只要标签保持不变，删除指令不会破坏跳转指令。

### 生成方法

使用树 API 生成方法包括创建一个 `MethodNode` 并初始化其字段。最有趣的部分是生成方法的代码。例如，3.1.5 节中的 `checkAndSetF` 方法可以像下面这样生成：

```java
MethodNode mn = new MethodNode(...);
InsnList il = mn.instructions;
il.add(new VarInsnNode(ILOAD, 1));
LabelNode label = new LabelNode();
il.add(new JumpInsnNode(IFLT, label));
il.add(new VarInsnNode(ALOAD, 0));
il.add(new VarInsnNode(ILOAD, 1));
il.add(new FieldInsnNode(PUTFIELD, "pkg/Bean", "f", "I"));
LabelNode end = new LabelNode();
il.add(new JumpInsnNode(GOTO, end));
il.add(label);
il.add(new FrameNode(F_SAME, 0, null, 0, null));
il.add(new TypeInsnNode(NEW, "java/lang/IllegalArgumentException"));
il.add(new InsnNode(DUP));
il.add(new MethodInsnNode(INVOKESPECIAL,"java/lang/IllegalArgumentException", "<init>", "()V"));
il.add(new InsnNode(ATHROW));
il.add(end);
il.add(new FrameNode(F_SAME, 0, null, 0, null));
il.add(new InsnNode(RETURN));
mn.maxStack = 2;
mn.maxLocals = 2;
```

与类一样，使用树 API 生成方法所需的时间更多，消耗的内存也更多。但它使得可以以任何顺序生成它们的内容。特别是指令可以以不同于顺序的方式生成，这在某些情况下可能很有用。

例如，考虑一个表达式编译器。通常，表达式 `e1 + e2` 是通过先发出 `e1` 的代码，然后发出 `e2` 的代码，最后发出添加两个值的代码来编译的。但是，如果 `e1` 和 `e2` 不是相同的基本类型，必须在 `e1` 的代码之后插入一个转换，在 `e2` 的代码之后插入另一个转换。然而，必须发出的确切转换取决于 `e1` 和 `e2` 的类型。

现在，如果表达式的类型由发出编译代码的方法返回，如果我们使用核心 API，就会有问题：只有在 `e2` 被编译之后才知道必须在 `e1` 之后插入的转换，但这太晚了，因为我们不能在之前访问过的指令之间插入指令。使用树 API，这个问题不存在。例如，一种可能性是使用一个 `compile` 方法，如下所示：

```java
public Type compile(InsnList output) {
    InsnList il1 = new InsnList();
    InsnList il2 = new InsnList();
    Type t1 = e1.compile(il1);
    Type t2 = e2.compile(il2);
    Type t = ...; // compute common super type of t1 and t2
    output.addAll(il1); // done in constant time
    output.add(...); // cast instruction from t1 to t
    output.addAll(il2); // done in constant time
    output.add(...); // cast instruction from t2 to t
    output.add(new InsnNode(t.getOpcode(IADD)));
    return t;
}
```

### 转换方法

使用树 API 转换方法仅包括修改 `MethodNode` 对象的字段，特别是指令列表。虽然这个列表可以以任意方式修改，但一个常见的模式是在迭代它时修改它。实际上，与 `ListIterator` 契约不同，`InsnList` 返回的 `ListIterator` 支持许多并发列表修改。实际上，您可以使用 `InsnList` 方法在当前元素之前和包括当前元素在内的一个或多个元素中删除一个或多个元素，删除下一个元素之后的一个或多个元素（即不仅是在当前元素之后，而是在其后续元素之后），或者在当前元素之前或其后续元素之后插入一个或多个元素。这些更改将反映在迭代器中，即插入（或删除）下一个元素之后的元素将在迭代器中看到（或看不到）。

当您需要在列表中的指令 `i` 之后插入多个指令时，修改指令列表的另一个常见模式是将这些新指令添加到一个临时指令列表中，然后一步将其插入主列表中：

```java
InsnList il = new InsnList();
il.add(...);
...
il.add(...);
mn.instructions.insert(i, il);
```

逐个插入指令也是可能的，但更繁琐，因为每次插入后必须更新插入点。

### 无状态和有状态转换

让我们通过一些例子具体看看如何使用树 API 转换方法。为了看到核心 API 和树 API 之间的差异，重新实现 3.2.4 节中的 `AddTimerAdapter` 示例和 3.2.5 节中的 `RemoveGetFieldPutFieldAdapter` 是很有趣的。计时器示例可以这样实现：

```java
public class AddTimerTransformer extends ClassTransformer {
    public AddTimerTransformer(ClassTransformer ct) {
        super(ct);
    }

    @Override
    public void transform(ClassNode cn) {
        for (MethodNode mn : (List<MethodNode>) cn.methods) {
            if ("<init>".equals(mn.name) || "<clinit>".equals(mn.name)) {
                continue;
            }
            InsnList insns = mn.instructions;
            if (insns.size() == 0) {
                continue;
            }
            Iterator<AbstractInsnNode> j = insns.iterator();
            while (j.hasNext()) {
                AbstractInsnNode in = j.next();
                int op = in.getOpcode();
                if ((op >= IRETURN && op <= RETURN) || op == ATHROW) {
                    InsnList il = new InsnList();
                    il.add(new FieldInsnNode(GETSTATIC, cn.name, "timer", "J"));
                    il.add(new MethodInsnNode(INVOKESTATIC, "java/lang/System",
                            "currentTimeMillis", "()J"));
                    il.add(new InsnNode(LADD));
                    il.add(new FieldInsnNode(PUTSTATIC, cn.name, "timer", "J"));
                    insns.insert(in.getPrevious(), il);
                }
            }
            InsnList il = new InsnList();
            il.add(new FieldInsnNode(GETSTATIC, cn.name, "timer", "J"));
            il.add(new MethodInsnNode(INVOKESTATIC, "java/lang/System", "currentTimeMillis", "()J"));
            il.add(new InsnNode(LSUB));
            il.add(new FieldInsnNode(PUTSTATIC, cn.name, "timer", "J"));
            insns.insert(il);
            mn.maxStack += 4;
        }
        int acc = ACC_PUBLIC + ACC_STATIC;
        cn.fields.add(new FieldNode(acc, "timer", "J", null, null));
        super.transform(cn);
    }
}
```

您可以看到这里讨论了在指令列表中插入多个指令的模式，该模式包括使用一个临时指令列表。这个例子还表明，在迭代指令列表时，可以在当前指令之前插入指令。请注意，实现这个适配器所需的代码量在使用核心 API 和树 API 时大致相同。
删除字段自赋值的方法适配器（见 3.2.5 节）可以这样实现（如果我们假设 `MethodTransformer` 类似于上一章的 `ClassTransformer` 类）：


```java
public class RemoveGetFieldPutFieldTransformer extends
MethodTransformer {
public RemoveGetFieldPutFieldTransformer(MethodTransformer mt) {
super(mt);
}
@Override public void transform(MethodNode mn) {
InsnList insns = mn.instructions;
Iterator<AbstractInsnNode> i = insns.iterator();
while (i.hasNext()) {
AbstractInsnNode i1 = i.next();
if (isALOAD0(i1)) {
AbstractInsnNode i2 = getNext(i1);
if (i2 != null && isALOAD0(i2)) {
AbstractInsnNode i3 = getNext(i2);
if (i3 != null && i3.getOpcode() == GETFIELD) {
AbstractInsnNode i4 = getNext(i3);
if (i4 != null && i4.getOpcode() == PUTFIELD) {
if (sameField(i3, i4)) {
while (i.next() != i4) {
}
insns.remove(i1);
insns.remove(i2);
insns.remove(i3);
insns.remove(i4);
}
}
}
}
}
}
super.transform(mn);
}
private static AbstractInsnNode getNext(AbstractInsnNode insn) {
do {
    insn = insn.getNext();
    if (insn != null && !(insn instanceof LineNumberNode)) {
        break;
    }
} while (insn != null);
    return insn;
}
    private static boolean isALOAD0(AbstractInsnNode i) {
        return i.getOpcode() == ALOAD && ((VarInsnNode) i).var == 0;
    }
    private static boolean sameField(AbstractInsnNode i,
                                     AbstractInsnNode j) {
        return ((FieldInsnNode) i).name.equals(((FieldInsnNode) j).name);
    }
}

```

在这里，我们再次看到在迭代指令列表时可以删除指令。但是请注意 `while (i.next() != i4)` 循环：这是必要的，以便将迭代器放置在必须删除的指令之后（因为不可能删除当前指令之后的指令）。基于访问者和基于树的实现都可以检测到序列中间的标签和帧，并且在这种情况下不会删除它们。但是，与核心 API 相比，忽略序列内的行号需要更多的代码（见 `getNext` 方法）。然而，两个实现之间的主要区别是，使用树 API 时不需要状态机。特别是连续三个或更多 `ALOAD 0` 指令的特殊情况，这在基于树的 API 中不再是问题。

使用上述实现，给定指令可能会被检查多次，因为，在 `while` 循环的每一步中，`i2`、`i3` 和 `i4`，这些将在未来迭代中被检查，也可能在这个迭代中被检查。实际上，可以使用一个更有效的实现，其中每个指令最多被检查一次：

```java
public class RemoveGetFieldPutFieldTransformer2 extends
MethodTransformer {
...
@Override public void transform(MethodNode mn) {
InsnList insns = mn.instructions;
Iterator i = insns.iterator();
while (i.hasNext()) {
AbstractInsnNode i1 = (AbstractInsnNode) i.next();
if (isALOAD0(i1)) {
AbstractInsnNode i2 = getNext(i);
if (i2 != null && isALOAD0(i2)) {
    AbstractInsnNode i3 = getNext(i);
    while (i3 != null && isALOAD0(i3)) {
        i1 = i2;
        i2 = i3;
        i3 = getNext(i);
    }
    if (i3 != null && i3.getOpcode() == GETFIELD) {
        AbstractInsnNode i4 = getNext(i);
        if (i4 != null && i4.getOpcode() == PUTFIELD) {
            if (sameField(i3, i4)) {
                insns.remove(i1);
                insns.remove(i2);
                insns.remove(i3);
                insns.remove(i4);
            }
        }
    }
}
}
}
    super.transform(mn);
}
    private static AbstractInsnNode getNext(Iterator i) {
        while (i.hasNext()) {
            AbstractInsnNode in = (AbstractInsnNode) i.next();
            if (!(in instanceof LineNumberNode)) {
                return in;
            }
        }
        return null;
    }
...
}
}
```

与之前的实现不同，`getNext` 方法现在作用于列表迭代器。当识别到序列时，迭代器就在它之后，因此不再需要 `while (i.next() != i4)` 循环。但是在这里，连续三个或更多 `ALOAD 0` 指令的特殊情况再次出现（见 `while (i3 != null)` 循环）。


### 全局变换

截至目前，我们所探讨的所有方法转换均为局部转换 —— 即便是有状态的转换也不例外。其核心特征在于：对某条指令 i 的转换仅依赖于与 i 相距固定间隔的指令。然而，还存在一类全局转换，在这类转换中，对指令 i 的转换可能会依赖于与 i 相隔任意距离的指令。对于这类转换而言，树形 API 的作用尤为关键；换言之，若试图利用核心 API 来实现这些转换，操作难度会极大。

一个例子是，将跳转到 GOTO 标签指令的跳转替换为跳转到某个标签，并将跳转到 RETURN 指令的 GOTO 替换为该 RETURN 指令。确实，跳转指令的目标可能与该指令距离任意远，无论是之前还是之后。这种变换可以这样实现：

```java
public class OptimizeJumpTransformer extends MethodTransformer {
public OptimizeJumpTransformer(MethodTransformer mt) {
super(mt);
}
@Override public void transform(MethodNode mn) {
InsnList insns = mn.instructions;
Iterator<AbstractInsnNode> i = insns.iterator();
while (i.hasNext()) {
AbstractInsnNode in = i.next();
if (in instanceof JumpInsnNode) {
LabelNode label = ((JumpInsnNode) in).label;
AbstractInsnNode target;
// while target == goto l, replace label with l
while (true) {
target = label;
while (target != null && target.getOpcode() < 0) {
target = target.getNext();
}
if (target != null && target.getOpcode() == GOTO) {
label = ((JumpInsnNode) target).label;
} else {
break;
}
}
// update target
((JumpInsnNode) in).label = label;
// if possible, replace jump with target instruction
if (in.getOpcode() == GOTO && target != null) {
int op = target.getOpcode();
if ((op >= IRETURN && op <= RETURN) || op == ATHROW) {
// replace ’in’ with clone of ’target’
insns.set(in, target.clone(null));
}
}
}
}
super.transform(mn);
}
}
```

这段代码的工作原理如下：当在 `in` 中找到跳转指令时，其目标存储在 `label` 中。然后，使用最内层的 `while` 循环搜索紧跟在这个标签后的指令（不表示真实指令的 `AbstractInsnNode` 对象，如 `FrameNode` 或 `LabelNode`，具有负的“操作码”）。只要这个指令是 GOTO，`label` 就被替换为这个指令的目标，并且重复前面的步骤。最后，`in` 的目标标签被替换为这个更新的 `label` 值，如果 `in` 本身是 GOTO 并且其更新的目标是 RETURN 指令，则 `in` 被替换为这个返回指令的克隆（请记住，指令对象在指令列表中不能出现多次）。
这种变换对 3.1.5 节中定义的 `checkAndSetF` 方法的影响如下：

```java
// before // after
ILOAD 1 ILOAD 1
IFLT label IFLT label
ALOAD 0 ALOAD 0
ILOAD 1 ILOAD 1
PUTFIELD ... PUTFIELD ...
GOTO end RETURN
label: label:
F_SAME F_SAME
NEW ... NEW ...
DUP DUP
INVOKESPECIAL ... INVOKESPECIAL ...
ATHROW ATHROW
end: end:
F_SAME F_SAME
RETURN RETURN
```

请注意，尽管这种转换改变了跳转指令（更正式地说，是控制流图），但它不需要更新方法帧。实际上，执行帧的状态在每个指令保持不变，并且由于没有引入新的跳转目标，因此不需要访问新的帧。然而，可能发生的情况是某个帧不再需要。例如，在上面的例子中，转换后不再使用结束标签，以及之后的 F_SAME 帧和 RETURN 指令。希望访问比严格必要的更多帧，以及将未使用的代码（称为死代码或不可达代码）包含在方法中是完全合法的。因此，上述方法适配器是正确的，即使它可能不是最优化的，因为它没有删除死代码和帧。

## 组合

到目前为止，我们只看到了如何创建和转换 `MethodNode` 对象，但我们还没有看到与类的字节数组表示之间的联系。与类一样，这种联系是通过组合核心 API 和树 API 组件来完成的，如本节所述。

### 说明

除了图 7.1 中显示的字段之外，`MethodNode` 类还扩展了 `MethodVisitor` 类，并提供了两个接受 `MethodVisitor` 或 `ClassVisitor` 作为参数的 `accept` 方法。`accept` 方法根据 `MethodNode` 字段值生成事件，而 `MethodVisitor` 方法执行逆操作，即根据接收的事件设置 `MethodNode` 字段。

### 模式

与类一样，可以使用基于树的类转换器，就像核心 API 中的类适配器一样。事实上，用于类的两种模式也适用于方法，并且工作方式完全相同。基于继承的模式如下：

```java
public class MyMethodAdapter extends MethodNode {
public MyMethodAdapter(int access, String name, String desc,
String signature, String[] exceptions, MethodVisitor mv) {
super(ASM4, access, name, desc, signature, exceptions);
this.mv = mv;
}
@Override public void visitEnd() {
// put your transformation code here
accept(mv);
}
}
```

基于委托的模式是：

```java
public class MyMethodAdapter extends MethodVisitor {
MethodVisitor next;
    public MyMethodAdapter(int access, String name, String desc,
                           String signature, String[] exceptions, MethodVisitor mv) {
        super(ASM4,
                new MethodNode(access, name, desc, signature, exceptions));
        next = mv;
    }
    @Override public void visitEnd() {
        MethodNode mn = (MethodNode) mv;
// put your transformation code here
        mn.accept(next);
    }
}
```

第一种模式的变体是直接在 `ClassAdapter` 的 `visitMethod` 中使用匿名内部类。

```java
public MethodVisitor visitMethod(int access, String name,
String desc, String signature, String[] exceptions) {
return new MethodNode(ASM4, access, name, desc, signature, exceptions)
{
@Override public void visitEnd() {
// put your transformation code here
accept(cv);
}
};
}
```

这些模式表明，可以使用树 API 仅用于方法，而核心 API 用于类。在实践中，这种策略经常被使用。

