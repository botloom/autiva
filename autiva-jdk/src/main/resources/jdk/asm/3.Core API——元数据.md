# 元数据

本章解释了如何使用核心 API 生成和转换编译后的 Java 类元数据，例如注解。每个部分都以介绍一种类型的元数据开始，然后介绍相应的 ASM 接口、组件和工具来生成和转换这些元数据，并提供一些示例。

## 泛型

像 `List<E>` 这样的泛型类以及使用它们的类包含有关它们声明或使用的泛型类型的信息。这些信息在运行时不会被字节码指令使用，但可以通过反射 API 访问。它也被编译器用于单独编译。

### 结构

由于向后兼容性的原因，关于泛型类型的信息不是存储在类型或方法描述符中（这些描述符在 Java 5 中引入泛型之前就已经定义），而是存储在称为类型、方法和类签名的类似结构中。当涉及泛型类型时，这些签名会存储在类、字段和方法声明中，除了描述符之外（泛型类型不影响方法的字节码：编译器使用它们来执行静态类型检查，但然后在需要时重新引入类型转换，就像没有使用泛型一样）。

与类型和方法描述符不同，由于泛型类型的递归性质（泛型类型可以由泛型类型参数化——例如 `List<List<E>>`），类型签名的语法相当复杂。它由以下规则给出（有关这些规则的完整描述，请参阅 Java 虚拟机规范）：

```bash
TypeSignature: Z | C | B | S | I | F | J | D | FieldTypeSignature
FieldTypeSignature: ClassTypeSignature | [ TypeSignature | TypeVar
ClassTypeSignature: L Id ( / Id )* TypeArgs? ( . Id TypeArgs? )* ;
TypeArgs: < TypeArg+ >
TypeArg: * | ( + | - )? FieldTypeSignature
TypeVar: T Id ;
```
第一条规则表示，类型签名是基本类型描述符或字段类型签名。第二条规则定义了字段类型签名：它是类类型签名、数组类型签名或类型变量。第三条规则定义了类类型签名：它们是类类型描述符，可能带有类型参数，这些参数位于尖括号内，位于主类名之后或内部类名之后（以点为前缀）。其余规则定义了类型参数和类型变量。注意，类型参数可以是完整的字段类型签名，带有自己的类型参数：因此，类型签名可以非常复杂。

| Java类型                        | 类型签名                                                    |
|-------------------------------|---------------------------------------------------------|
| List\<E>                      | Ljava/util/List<TE;>;                                   |
| List<?>                       | Ljava/util/List<*>;                                     |
| List<? extends Number>        | Ljava/util/List<+Ljava/lang/Number;>;                   |
| List<? super Integer>         | Ljava/util/List<-Ljava/lang/Integer;>;                  |
| List<List<String>[]>          | Ljava/util/List<[Ljava/util/List<Ljava/lang/String;>;>; |
| HashMap<K, V>.HashIterator<K> | Ljava/util/HashMap<TK;TV;>.HashIterator<TK;>;           |

方法签名扩展了方法描述符，就像类型签名扩展了类型描述符一样。方法签名描述了方法参数的类型签名以及其返回类型的签名。与方法描述符不同，它还包含了方法抛出的异常的签名，这些异常前面带有 ^，并且还可以在尖括号之间包含可选的形式类型参数：

```bash
MethodTypeSignature:
TypeParams? ( TypeSignature* ) ( TypeSignature | V ) Exception*
Exception: ^ClassTypeSignature | ^TypeVar
TypeParams: < TypeParam+ >
TypeParam: Id : FieldTypeSignature? ( : FieldTypeSignature )*
```

例如，以下泛型静态方法的签名，它由类型变量 T 参数化：

```java
static <T> Class<? extends T> m (int n)
```

是以下方法签名：

```bash
<T:Ljava/lang/Object;>(I)Ljava/lang/Class<+TT;>;
```

最后，类签名（不应与类类型签名混淆）定义为它的超类的类型签名，后面跟着实现的接口的类型签名，以及可选的形式类型参数：

```java
ClassSignature: TypeParams? ClassTypeSignature ClassTypeSignature*
```
例如，一个声明为 `C<E> extends List<E>` 的类的类签名是 `<E:Ljava/lang/Object;>Ljava/util/List<TE;>;`。

### 接口和组件

与描述符一样，出于同样的效率原因，ASM API 公开了编译类中存储的签名（签名的出现主要是在 ClassVisitor 类的 visit、visitField 和 visitMethod 方法中，分别作为可选的类、类型或方法签名参数）。幸运的是，它还提供了一些工具来生成和转换签名，这些工具位于 org.objectweb.asm.signature 包中，基于 SignatureVisitor 抽象类。

```java
public abstract class SignatureVisitor {
    public final static char EXTENDS = ’+’;
    public final static char SUPER = ’-’;
    public final static char INSTANCEOF = ’=’;
    public SignatureVisitor(int api);
    public void visitFormalTypeParameter(String name);
    public SignatureVisitor visitClassBound();
    public SignatureVisitor visitInterfaceBound();
    public SignatureVisitor visitSuperclass();
    public SignatureVisitor visitInterface();
    public SignatureVisitor visitParameterType();
    public SignatureVisitor visitReturnType();
    public SignatureVisitor visitExceptionType();
    public void visitBaseType(char descriptor);
    public void visitTypeVariable(String name);
    public SignatureVisitor visitArrayType();
    public void visitClassType(String name);
    public void visitInnerClassType(String name);
    public void visitTypeArgument();
    public SignatureVisitor visitTypeArgument(char wildcard);
    public void visitEnd();
}

```

这个抽象类用于访问类型签名、方法签名和类签名。用于访问类型签名的方法用粗体表示，并且必须按照以下顺序调用，这反映了之前的语法规则（注意其中两个方法返回一个 SignatureVisitor：这是由于类型签名的递归定义）。

```java

visitBaseType | visitArrayType | visitTypeVariable |
( visitClassType visitTypeArgument*
( visitInnerClassType visitTypeArgument* )* visitEnd ) )
```

用于访问方法签名的方法如下：

```java
( visitFormalTypeParameter visitClassBound? visitInterfaceBound* )*
visitParameterType* visitReturnType visitExceptionType*
```

最后，用于访问类签名的方法是：

```java
( visitFormalTypeParameter visitClassBound? visitInterfaceBound* )*
visitSuperClass visitInterface*
```

大多数这些方法返回一个 `SignatureVisitor`：它的目的是访问类型签名。请注意，与由 `ClassVisitor` 返回的 `MethodVisitors` 不同，`SignatureVisitor` 返回的 `SignatureVisitors` 不能为空，并且必须按顺序使用：实际上，在嵌套签名完全访问之前，不能调用父访问者的任何方法。

与类一样，ASM API 提供了基于此 API 的两个组件：`SignatureReader` 组件解析签名，并在给定的签名访问者上调用适当的访问方法，`SignatureWriter` 组件根据接收到的调用构建签名。

这两个类可以用来生成和转换签名，使用与类和方法相同的原则。例如，假设您想要重命名某些签名中出现的类名。这可以通过以下签名适配器完成，该适配器转发它接收到的所有方法调用，除了 `visitClassType` 和 `visitInnerClassType` 方法（我们假设这里 `sv` 方法总是返回 `this`，这是 `SignatureWriter` 的情况）：

```java
public class RenameSignatureAdapter extends SignatureVisitor {
    private SignatureVisitor sv;
    private Map<String, String> renaming;
    private String oldName;
    public RenameSignatureAdapter(SignatureVisitor sv,
                                  Map<String, String> renaming) {
        super(ASM4);
        this.sv = sv;
        this.renaming = renaming;
    }
    public void visitFormalTypeParameter(String name) {
        sv.visitFormalTypeParameter(name);
    }
    public SignatureVisitor visitClassBound() {
        sv.visitClassBound();
        return this;
    }
    public SignatureVisitor visitInterfaceBound() {
        sv.visitInterfaceBound();
        return this;
    }
...
    public void visitClassType(String name) {
        oldName = name;
        String newName = renaming.get(oldName);
        sv.visitClassType(newName == null ? name : newName);
    }
    public void visitInnerClassType(String name) {
        oldName = oldName + "." + name;
        String newName = renaming.get(oldName);
        sv.visitInnerClassType(newName == null ? name : newName);
    }
    public void visitTypeArgument() {
        sv.visitTypeArgument();
    }
    public SignatureVisitor visitTypeArgument(char wildcard) {
        sv.visitTypeArgument(wildcard);
        return this;
    }
    public void visitEnd() {
        sv.visitEnd();
    }
}
```

然后，以下代码的结果是 "LA<TK;TV;>.B<TK;>;"：

```java
String s = "Ljava/util/HashMap<TK;TV;>.HashIterator<TK;>;";
Map<String, String> renaming = new HashMap<String, String>();
renaming.put("java/util/HashMap", "A");
renaming.put("java/util/HashMap.HashIterator", "B");
SignatureWriter sw = new SignatureWriter();
SignatureVisitor sa = new RenameSignatureAdapter(sw, renaming);
SignatureReader sr = new SignatureReader(s);
sr.acceptType(sa);
sw.toString();
```

## 注解

类、字段、方法和方法参数注解，如 `@Deprecated` 或 `@Override`，如果它们的保留策略不是 `RetentionPolicy.SOURCE`，则存储在编译后的类中。这些信息在运行时不会被字节码指令使用，但如果保留策略是 `RetentionPolicy.RUNTIME`，则可以通过反射 API 访问。它也可以被编译器使用。

### 结构

源代码中的注解可以有不同的形式，例如 `@Deprecated`、`@Retention(RetentionPolicy.CLASS)` 或 `@Task(desc="refactor", id=1)`。然而，在内部，所有注解都有相同的形式，并且由一个注解类型和一组名称-值对指定，其中值限制为：
* 基本类型、字符串或类值，
* 枚举值，
* 注解值，
* 以上值的数组。
  请注意，一个注解可以包含其他注解，甚至注解数组。因此，注解可能相当复杂。

### 接口和组件

生成和转换注解的 ASM API 基于 `AnnotationVisitor` 抽象类：

```java
public abstract class AnnotationVisitor {
    public AnnotationVisitor(int api);
    public AnnotationVisitor(int api, AnnotationVisitor av);
    public void visit(String name, Object value);
    public void visitEnum(String name, String desc, String value);
    public AnnotationVisitor visitAnnotation(String name, String desc);
    public AnnotationVisitor visitArray(String name);
    public void visitEnd();
}
```

注解（注解类型在返回此类型的方法中访问，即 `visitAnnotation` 方法）。第一个方法用于基本类型、字符串和类值（后者由 Type 对象表示），其他方法用于枚举、注解和数组值。它们可以以任何顺序调用，除了 `visitEnd`：

```java
( visit | visitEnum | visitAnnotation | visitArray )* visitEnd
```

请注意，两个方法返回一个 `AnnotationVisitor`：这是因为注解可以包含其他注解。与 `ClassVisitor` 返回的 `MethodVisitors` 不同，这两个方法返回的 `AnnotationVisitors` 必须按顺序使用：实际上，在嵌套注解完全访问之前，不能调用父访问者的任何方法。

还请注意，`visitArray` 方法返回一个 `AnnotationVisitor` 来访问数组的元素。然而，由于数组的元素没有命名，`visitArray` 返回的访问者的方法会忽略名称参数，并且可以将它们设置为 `null`。

### 添加、删除、监测注解

与字段和方法一样，通过在 `visitAnnotation` 方法中返回 `null`，可以删除注解：

```java
public class RemoveAnnotationAdapter extends ClassVisitor {
private String annDesc;
public RemoveAnnotationAdapter(ClassVisitor cv, String annDesc) {
super(ASM4, cv);
this.annDesc = annDesc;
}
@Override
public AnnotationVisitor visitAnnotation(String desc, boolean vis) {
if (desc.equals(annDesc)) {
return null;
}
return cv.visitAnnotation(desc, vis);
}
}
```

由于对 `ClassVisitor` 类方法调用的约束，添加类注解更为困难。确实，所有可能跟随 `visitAnnotation` 的方法都必须被覆盖，以检测何时所有注解都已被访问（由于 `visitCode` 方法，添加方法注解更容易）：

```java
public class AddAnnotationAdapter extends ClassVisitor {
private String annotationDesc;
private boolean isAnnotationPresent;
public AddAnnotationAdapter(ClassVisitor cv, String annotationDesc) {
super(ASM4, cv);
this.annotationDesc = annotationDesc;
}
@Override public void visit(int version, int access, String name,
String signature, String superName, String[] interfaces) {
    int v = (version & 0xFF) < V1_5 ? V1_5 : version;
    cv.visit(v, access, name, signature, superName, interfaces);
}
    @Override public AnnotationVisitor visitAnnotation(String desc,
                                                       boolean visible) {
        if (visible && desc.equals(annotationDesc)) {
            isAnnotationPresent = true;
        }
        return cv.visitAnnotation(desc, visible);
    }
    @Override public void visitInnerClass(String name, String outerName,
                                          String innerName, int access) {
        addAnnotation();
        cv.visitInnerClass(name, outerName, innerName, access);
    }
    @Override
    public FieldVisitor visitField(int access, String name, String desc,
                                   String signature, Object value) {
        addAnnotation();
        return cv.visitField(access, name, desc, signature, value);
    }
    @Override
    public MethodVisitor visitMethod(int access, String name,
                                     String desc, String signature, String[] exceptions) {
        addAnnotation();
        return cv.visitMethod(access, name, desc, signature, exceptions);
    }
    @Override public void visitEnd() {
        addAnnotation();
        cv.visitEnd();
    }
    private void addAnnotation() {
        if (!isAnnotationPresent) {
            AnnotationVisitor av = cv.visitAnnotation(annotationDesc, true);
            if (av != null) {
                av.visitEnd();
            }
            isAnnotationPresent = true;
        }
    }
}

```

请注意，如果类版本小于 1.5，此适配器会将类版本升级到 1.5。这是必要的，因为 JVM 会忽略版本小于 1.5 的类中的注解。

类和方法适配器中注解的最后一个和可能是最常见的使用场景是使用注解来参数化转换。例如，您可以将字段访问仅转换为带有 `@Persistent` 注解的字段，仅将日志代码添加到带有 `@Log` 注解的方法中，等等。所有这些使用场景都可以轻松实现，因为注解必须首先被访问：类注解必须在字段和方法之前被访问，方法和参数注解必须在代码之前被访问。因此，当检测到所需的注解时设置一个标志，并在转换中使用它就足够了，就像上面的例子中使用 `isAnnotationPresent` 标志一样。
